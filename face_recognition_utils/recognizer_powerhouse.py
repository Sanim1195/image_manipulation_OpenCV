# Contains bunch of functions that improves the face_recognition.py model

import cv2 as cv
import numpy as np


# image_path = "./asset/mjTest1.jpg"
# img= cv.imread(image_path)
# image = cv.cvtColor(img,cv.COLOR_BGR2GRAY)


def image_rotation(image, rotation_angle=90, scale=1.0):
    """ Rotation**:
        Rotate the image by a certain angle (e.g., 15 degrees, 30 degrees, etc.).
        Helps the model handle different orientations of faces.
    """
    # getting the shape of image whilst ignoring the color channel
    (h,w) = image.shape[:2]
    image_center = (w//2,h//2)
    rotation_matrix = cv.getRotationMatrix2D(image_center,rotation_angle,scale)
    new_w, new_h = calculate_box_dimension(rotation_matrix,(h,w),image_center)
    # applying the rotation usingwarpAffine
    rotated_image = cv.warpAffine(image,rotation_matrix,(new_w,new_h))
    return(rotated_image)


def calculate_box_dimension(M,previous_dimensions,center):
    """ Calculate the new bounding box dimensions and returns new width and new height
        The matrix M is the rotation matrix generated by cv2.getRotationMatrix2D. It is a 2x3 matrix used to rotate the image. """
    h,w = previous_dimensions
    cos = np.abs(M[0, 0])
    sin = np.abs(M[0, 1])
    # calculate the new width and height after rotation
    new_w = int((h * sin) + (w * cos))
    new_h = int((h * cos) + (w * sin))

    # Adjust the rotation matrix to account for translation
    """ M[0, 2] and M[1, 2]: These are the translation components of the rotation matrix, which control the position of the rotated image within the new bounding box.
    (new_w / 2) and (new_h / 2): These are the new center coordinates of the bounding box after rotation (calculated based on the new width and height).
    center[0] and center[1]: These are the original center coordinates of the image, calculated before rotation.
    The difference between (new_w / 2, new_h / 2) and (center[0], center[1]) tells us how much we need to shift the image in the new bounding box to ensure the rotated image is properly centered.
 """
    M[0, 2] += (new_w / 2) - center[0]
    M[1, 2] += (new_h / 2) - center[1]

    # Perform the rotation with the new dimensions
    return(new_w,new_h)

# image_rotation(img)